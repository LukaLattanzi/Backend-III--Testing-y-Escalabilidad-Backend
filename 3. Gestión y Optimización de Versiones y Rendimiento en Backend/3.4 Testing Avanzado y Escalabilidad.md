# Testing Avanzado con Configuración Personalizada de Artillery

Descripción de cómo configurar pruebas avanzadas de Artillery mediante archivos `config.yml`.

Artillery es una herramienta poderosa para realizar pruebas de rendimiento y carga en servidores. Su verdadero potencial se muestra al usar archivos `config.yml`, que permiten simular flujos con múltiples peticiones y escenarios complejos que imitan usuarios reales.

## Estructura básica de un archivo `config.yml`

### Configuración global

En la sección `config` se definen el objetivo (`target`), las fases de carga (`phases`), y otros parámetros globales.

Ejemplo:

```yaml
config:
    target: "http://mi-servidor.com"
    phases:
        - duration: 60
            arrivalRate: 10
```

### Escenarios

Los `scenarios` definen los flujos que seguirá cada usuario simulado: múltiples endpoints, distintos métodos (GET, POST, etc.) y datos dinámicos.

Ejemplo:

```yaml
config:
    target: "http://mi-servidor.com"
    phases:
        - duration: 60
            arrivalRate: 10

scenarios:
    - name: Flujo básico de autenticación
        flow:
            - get:
                    url: "/api/usuarios"
            - post:
                    url: "/api/login"
                    json:
                        usuario: "testuser"
                        password: "password123"
```

### Variables y funciones

Se pueden usar funciones para procesar respuestas y reutilizar datos posteriormente.

Ejemplo:

```yaml
config:
    target: "http://mi-servidor.com"
    phases:
        - duration: 60
            arrivalRate: 10

scenarios:
    - name: Flujo dinámico con datos generados
        flow:
            - get:
                    url: "/api/generate-user"
                    afterResponse:
                        - function: "guardarUsuario"
            - post:
                    url: "/api/login"
                    json:
                        usuario: "{{ guardarUsuario.usuario }}"
                        password: "{{ guardarUsuario.password }}"
```

(La función `guardarUsuario` se define en un archivo JS externo referenciado mediante `processor`.)

## Características avanzadas de configuración

### Simulación de flujos complejos

Puedes definir un flujo completo: registro, login y acciones posteriores dentro de la misma sesión virtual para evaluar impacto acumulado en el backend.

### Pruebas escalonadas y fases múltiples

Las fases permiten aumentar o variar la carga gradualmente.

Ejemplo:

```yaml
config:
    target: "http://mi-servidor.com"
    phases:
        - duration: 120
            arrivalRate: 5
        - duration: 60
            arrivalRate: 10
        - duration: 30
            arrivalRate: 20
```

### Integración de plugins y métricas personalizadas

Plugins pueden agregar almacenamiento de métricas, separar resultados por endpoint o exportar datos para análisis posterior.

## Comandos principales para ejecutar pruebas avanzadas

- Ejecutar prueba:  
   `artillery run config.yml`
- Generar reporte HTML:  
   `artillery run config.yml -o reporte.json && artillery report reporte.json`
- Ajustar nivel de log:  
   `artillery run config.yml --overrides "{ log: { level: 'info' } }"`

## Conclusión (Testing)

El uso de `config.yml` en Artillery permite simulaciones robustas y cercanas al tráfico real, anticipando cuellos de botella y validando la preparación para producción.

---

# Mejorando la Escalabilidad del Servidor

Estrategias para potenciar la escalabilidad del backend mediante clustering, gestión eficiente de recursos y retroalimentación de pruebas de rendimiento.

## 1. Clustering para escalabilidad

El clustering distribuye la carga entre múltiples procesos (ideal en entornos multicore, p. ej. con `cluster` en Node.js).

Ventajas:

- Mejor uso del CPU: aprovecha todos los núcleos.
- Redundancia: tolerancia a fallos de un worker.
- Distribución de carga: evita cuellos de botella en un único proceso.

Ejemplo básico en Node.js:

```js
import cluster from "node:cluster";
import { cpus } from "node:os";
import http from "node:http";

if (cluster.isPrimary) {
  const numWorkers = cpus().length;
  for (let i = 0; i < numWorkers; i++) cluster.fork();
  cluster.on("exit", (worker) => {
    console.log(`Worker ${worker.process.pid} muerto. Reiniciando...`);
    cluster.fork();
  });
} else {
  http
    .createServer((req, res) => {
      res.end(`PID: ${process.pid}`);
    })
    .listen(3000);
}
```

## 2. Manejo eficiente de recursos

Claves:

- Optimización de consultas: índices, caché (Redis), reducción de N+1.
- Gestión de memoria: evitar fugas, usar profiling (heap snapshots).
- Balanceo de carga: Nginx, HAProxy o balanceadores cloud.
- Conexiones a BD: pools bien dimensionados y cierre adecuado.
- Caching multinivel: aplicación, CDN y base de datos.

## 3. Integración de resultados de testing para ajustes de rendimiento

- Análisis de cuellos de botella: CPU, I/O, latencias de DB, lock contention.
- Ajustes dinámicos: cambiar número de workers según métricas (p. ej. PM2 cluster mode).
- Monitoreo continuo: integrar Artillery en CI y comparar percentiles (p95/p99) con umbrales.

Ejemplo pipeline (pseudo):

```bash
artillery run config.yml -o results.json
artillery report results.json
node verificar-umbral.js results.json  # Falla si p95 > 400ms
```

## Conclusión (Escalabilidad)

Combinar clustering, optimización de recursos y ciclos iterativos de pruebas de carga crea una base sólida para un backend capaz de crecer manteniendo estabilidad y rendimiento constantemente altos.
