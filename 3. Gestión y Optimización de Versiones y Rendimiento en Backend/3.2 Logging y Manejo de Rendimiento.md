# Loggers en Aplicaciones Node.js

## Introducción

En aplicaciones backend con Node.js, manejar logs de forma eficiente es clave para depuración, monitoreo y mantenimiento. Winston es uno de los loggers más usados por su flexibilidad, soporte de múltiples destinos (transportes) y configuración según entorno.

## ¿Qué es un logger y por qué es importante?

Un logger registra eventos de la aplicación con distintos niveles de importancia. A diferencia de `console.log`, herramientas como Winston permiten:

- Niveles de severidad (info, warn, error, etc.).
- Múltiples transportes (consola, archivos, HTTP, servicios externos).
- Configuración según entorno (desarrollo, pruebas, producción).
- Formatos estructurados (JSON, timestamps, colores).

## Niveles de prioridad (ejemplos comunes)

- error: Fallos que requieren atención inmediata.
- warn: Advertencias que no detienen la ejecución.
- info: Información general del flujo.
- debug: Datos útiles para depuración.
  (Se pueden añadir otros como silly, verbose según necesidad.)

## Transportes

Algunos transportes típicos:

- Consola: Ideal en desarrollo.
- Archivos: Persistencia para auditoría o análisis post-mortem.
- HTTP / APIs externas: Envío a servicios de monitoreo (Elastic, Datadog, etc.).
- Base de datos u otros canales personalizados.

## Ejemplo básico de configuración

```js
import { createLogger, format, transports } from "winston";

const logger = createLogger({
  level: "debug", // Nivel mínimo que se registrará
  format: format.combine(
    format.timestamp(),
    format.colorize(),
    format.printf(
      ({ level, message, timestamp }) => `[${timestamp}] ${level}: ${message}`
    )
  ),
  transports: [new transports.Console()],
});

logger.debug("Mensaje de depuración");
logger.info("Inicio de la aplicación");
logger.warn("Uso de recurso cercano al límite");
logger.error("Error crítico encontrado");
export default logger;
```

## Configuración multientorno

```js
import { createLogger, format, transports } from "winston";

const isProd = process.env.NODE_ENV === "production";

const logger = createLogger({
  level: isProd ? "info" : "debug",
  format: format.combine(
    format.timestamp(),
    isProd
      ? format.json()
      : format.printf(
          ({ level, message, timestamp }) =>
            `[${timestamp}] ${level}: ${message}`
        )
  ),
  transports: [
    new transports.Console({ stderrLevels: ["error"] }),
    ...(isProd
      ? [new transports.File({ filename: "logs/errors.log", level: "error" })]
      : []),
  ],
  exceptionHandlers: [new transports.File({ filename: "logs/exceptions.log" })],
  rejectionHandlers: [new transports.File({ filename: "logs/rejections.log" })],
});

export default logger;
```

Descripción:

- Desarrollo: todos los niveles en consola con formato legible.
- Producción: salida mínima, formato JSON, errores en archivo.
- Manejo de excepciones y promesas rechazadas para diagnósticos.

## Buenas prácticas

- No loggear datos sensibles (tokens, contraseñas).
- Rotar archivos (usar winston-daily-rotate-file o logrotate).
- Estandarizar estructura (correlación con requestId).
- Ajustar nivel por entorno (debug solo en desarrollo).
- Integrar con APM/observabilidad (OpenTelemetry, etc.).

## Conclusión

Winston facilita un logging estructurado, escalable y adaptado al entorno, mejorando la visibilidad y mantenimiento de aplicaciones Node.js.
