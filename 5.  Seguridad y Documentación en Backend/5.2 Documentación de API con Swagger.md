# Documentación de API con Swagger

## 1. Importancia de la Documentación en el Mantenimiento y Desarrollo de Sistemas Backend

La documentación en sistemas backend es esencial para garantizar comprensión, mantenibilidad y escalabilidad. Sirve como guía para desarrolladores actuales y futuros, facilita la resolución de problemas y evita la pérdida de conocimiento.

### 1.1 Razones Clave

#### Facilita la comprensión del sistema

Los sistemas backend suelen incluir:

- Bases de datos
- APIs internas y externas
- Servicios de terceros
- Lógica de negocio
  Una buena documentación explica interacciones, configuraciones y responsabilidades.

#### Mejora la mantenibilidad

Permite implementar cambios (bugs, features, performance) reduciendo riesgos.

#### Acelera la resolución de problemas

Aclara configuraciones, dependencias y comportamiento esperado.

#### Preserva el conocimiento institucional

Reduce dependencia de personas clave y evita pérdida de contexto.

### 1.2 Problemas Comunes Cuando la Documentación es Inadecuada

#### Dependencia en conocimiento tribal

Ejemplo: Scripts críticos solo entendidos por un desarrollador → retrasos tras su salida.

#### Dificultad para resolver problemas

Ejemplo: Falla de conexión a base de datos sin registros de configuración → mayor downtime.

#### Inconsistencias en el desarrollo

Ejemplo: Múltiples implementaciones de hashing de contraseñas → riesgo de seguridad.

#### Retrasos en onboarding

Ejemplo: Nuevo integrante tarda semanas en entender arquitectura sin una guía clara.

### 1.3 Conclusión

Invertir en documentación clara y mantenida reduce errores, acelera incorporación y mejora la calidad general del sistema.

---

## 2. Recomendaciones para Estructurar la Documentación de APIs con Swagger

Swagger (OpenAPI) permite describir y explorar APIs de forma estandarizada e interactiva.

### 2.1 Elementos Clave

#### Descripción general

Incluye:

- Propósito de la API
- Casos de uso principales
- Versión (semántica recomendada: MAJOR.MINOR.PATCH)

#### Endpoints (rutas)

Para cada endpoint:

- Método HTTP (GET, POST, PUT, PATCH, DELETE, etc.)
- Ruta completa
- Descripción breve
- Tags (agrupación lógica)

#### Schemas de datos

Definir:

- Objetos de entrada (request bodies)
- Objetos de salida (responses)
- Tipos, formatos, campos obligatorios (required), enumeraciones
- Ejemplos (`example` o `examples`)

#### Parámetros de entrada

Tipos:

- Path parameters (obligatorios)
- Query parameters (opcionalidad, tipos, defaults)
- Headers
- Body (JSON, multipart, form-data)
- Cookies (si aplica)

#### Respuestas

Para cada código:

- Código HTTP (200, 201, 400, 401, 404, 422, 500, etc.)
- Descripción
- Schema del cuerpo
- Ejemplos de éxito y error

#### Autenticación y autorización

Especificar:

- Tipo: Bearer JWT, OAuth2, API Key
- Scopes (si aplica)
- Ejemplo de header:
  ```
  Authorization: Bearer <token>
  ```

#### Ejemplos de solicitudes y respuestas

Proveer:

- Curl
- JSON de request y response
- Casos de error con mensajes consistentes

### 2.2 Ejemplo Simplificado (OpenAPI 3.0)

```yaml
openapi: 3.0.3
info:
    title: API de Pedidos
    version: 1.2.0
    description: API para gestionar pedidos.
servers:
    - url: https://api.ejemplo.com/v1
paths:
    /orders:
        get:
            summary: Lista pedidos
            tags: [Pedidos]
            parameters:
                - in: query
                    name: status
                    schema:
                        type: string
                        enum: [pending, paid, shipped]
                    description: Filtra por estado
            responses:
                '200':
                    description: Lista de pedidos
                    content:
                        application/json:
                            schema:
                                type: array
                                items:
                                    $ref: '#/components/schemas/Order'
    /orders/{id}:
        get:
            summary: Obtiene un pedido
            tags: [Pedidos]
            parameters:
                - in: path
                    name: id
                    required: true
                    schema:
                        type: string
            responses:
                '200':
                    description: Pedido encontrado
                    content:
                        application/json:
                            schema:
                                $ref: '#/components/schemas/Order'
                '404':
                        description: No encontrado
components:
    schemas:
        Order:
            type: object
            required: [id, status, total]
            properties:
                id:
                    type: string
                    example: ord_123
                status:
                    type: string
                    enum: [pending, paid, shipped]
                total:
                    type: number
                    format: float
                    example: 149.99
security:
    - bearerAuth: []
```

### 2.3 Mantención y Flujo de Trabajo

#### Documentación automática

- Generar desde anotaciones (NestJS, Spring, FastAPI, Laravel, Express + decorators)
- Servir Swagger-UI / ReDoc en entorno interno (ej: /docs)

#### Integración CI/CD

- Validar archivo OpenAPI (speccy, spectral)
- Publicar versión en cada release
- Generar SDKs (openapi-generator) para clientes

#### Revisiones

- Checklist de PR debe incluir: ¿Actualizaste OpenAPI?
- Bloquear merge si falla validación del spec

#### Accesibilidad

- Punto central (portal /docs)
- Versionado accesible (/docs/v1, /docs/v2)
- Changelog visible

#### Changelog

Estructura sugerida:

- Added
- Changed
- Deprecated
- Removed
- Fixed
- Security

### 2.4 Buenas Prácticas

- Usar nombres consistentes en recursos (plural: /orders, /users)
- Evitar devolver estructuras distintas para el mismo concepto
- Estandarizar errores (ejemplo):
  ```json
  {
    "error": "VALIDATION_ERROR",
    "message": "Campo 'email' inválido",
    "details": [{ "field": "email", "rule": "format" }]
  }
  ```
- No exponer información sensible en ejemplos
- Incluir límites (rate limits) y políticas de paginación
- Documentar formatos de fechas (ISO 8601 recomendado)

### 2.5 Ejemplo de Paginación Documentada

```yaml
parameters:
    - in: query
        name: page
        schema:
            type: integer
            minimum: 1
            default: 1
    - in: query
        name: pageSize
        schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
responses:
    '200':
        content:
            application/json:
                schema:
                    type: object
                    properties:
                        data:
                            type: array
                            items:
                                $ref: '#/components/schemas/Order'
                        meta:
                            type: object
                            properties:
                                page:
                                    type: integer
                                pageSize:
                                    type: integer
                                totalItems:
                                    type: integer
                                totalPages:
                                    type: integer
```

---

## 3. Conclusión

Una documentación clara basada en OpenAPI/Swagger:

- Reduce fricción entre equipos
- Evita ambigüedades
- Permite generación de clientes y mocks
- Acelera incorporación y debugging
- Minimiza riesgos en cambios y versiones

Mantenerla como artefacto vivo en el ciclo de desarrollo es crítico para la calidad y evolución sostenible del backend.
