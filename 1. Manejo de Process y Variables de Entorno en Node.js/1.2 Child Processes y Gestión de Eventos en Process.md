# Child Processes y Gestión de Eventos en `process`

## 1. Introducción

En Node.js, los procesos secundarios (child processes) permiten ejecutar tareas en paralelo al proceso principal para evitar bloqueos del event loop. Esto es útil para:

- Cálculos intensivos
- Procesamiento de imágenes o datos
- Aislar tareas independientes

## 2. ¿Qué es `fork()`?

`fork()` (del módulo `child_process`) crea un nuevo proceso que ejecuta un archivo JavaScript de Node.js. A diferencia de `spawn()` o `exec()`, está optimizado para scripts Node y abre automáticamente un canal de comunicación (IPC) para enviar/recibir mensajes entre el proceso padre e hijo.

```js
// main.js
const { fork } = require("child_process");

console.log("Iniciando proceso principal", process.pid);

const child = fork("./worker.js");

// Enviar mensaje al hijo
child.send({ tarea: "calcular", payload: 500000 });

// Recibir respuesta del hijo
child.on("message", (msg) => {
  console.log("Mensaje del hijo:", msg);
});

// Escuchar salida del hijo
child.on("exit", (code) => {
  console.log(`Proceso hijo finalizó con código ${code}`);
});
```

```js
// worker.js
console.log("Proceso hijo iniciado", process.pid);

process.on("message", (msg) => {
  if (msg.tarea === "calcular") {
    // Simulación de trabajo intensivo
    let total = 0;
    for (let i = 0; i < msg.payload; i++) total += i;
    process.send({ resultado: total });
    process.exit(0);
  }
});
```

## 3. ¿Por qué usar `fork()`?

- Evitar bloqueo del event loop
- Escalabilidad en tareas CPU-bound
- Aislamiento (si el hijo falla, no tumba el padre)
- Comunicación simple vía mensajes

## 4. Comunicación principal ↔ secundario

Canal IPC integrado:

- `child.send(data)` desde el padre
- `process.send(data)` desde el hijo
- Evento `message` en ambos extremos

## 5. Manejo de Eventos con `process.on()`

`process` es un `EventEmitter`. Escuchar eventos permite controlar el ciclo de vida y errores.

### Eventos comunes

#### `exit`

Se emite justo antes de finalizar el proceso.

```js
process.on("exit", (code) => {
  console.log("Saliendo. Código:", code);
});
```

#### `uncaughtException`

Se dispara ante una excepción no manejada.

```js
process.on("uncaughtException", (err) => {
  console.error("Error no capturado:", err);
  // Posible logging y salida controlada
  process.exit(1);
});

// Forzar error
setTimeout(() => {
  throw new Error("Fallo inesperado");
}, 100);
```

Nota: tras un `uncaughtException`, el estado puede ser inestable. Preferir try/catch y promesas bien manejadas.

#### `message`

En procesos hijos recibe mensajes del padre.

```js
process.on("message", (msg) => {
  console.log("Mensaje recibido en hijo:", msg);
});
```

## 6. Códigos de salida (`process.exit(code)`)

- 0: Terminación correcta (por defecto)
- 1: Error genérico / fallo no manejado
- > 1: Significados específicos (definidos por la app o el runtime)

Ejemplo:

```js
if (!configValida()) {
  console.error("Configuración inválida");
  process.exit(1);
}
process.exit(0);
```

## 7. Caso de Uso Ejemplo

Delegar un cálculo intensivo (ej. agregaciones) a un hijo:

- El padre sigue atendiendo HTTP
- El hijo procesa y devuelve resultado
- Evita bloqueo de peticiones

## 8. Conclusiones

`fork()` permite paralelizar tareas CPU-bound manteniendo responsividad.  
`process.on()` facilita:

- Limpieza en `exit`
- Registro de errores críticos
- Comunicación entre procesos

Entender códigos de salida y eventos mejora monitoreo, tolerancia a fallos y depuración.
