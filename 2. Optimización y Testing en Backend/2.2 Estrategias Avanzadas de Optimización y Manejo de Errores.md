# Middleware de Manejo de Errores Personalizados

Configurar un middleware centralizado de errores en Express permite:

- Respuestas coherentes y con códigos HTTP adecuados.
- Registro unificado (logging) y fácil depuración.
- Separar lógica de negocio de la gestión de fallos.

## Tipos de errores comunes

- Validación (400)
- Autenticación / Autorización (401 / 403)
- Negocio (422 u otro acorde al caso)
- No encontrado (404)
- Servidor interno (500)
- Dependencias externas (502 / 503 / 504)

## Ejemplo de middleware Express

```js
// errors/AppError.js
export class AppError extends Error {
  constructor(message, statusCode = 500, details = {}) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
    this.isOperational = true;
  }
}

// middleware/errorHandler.js
export function errorHandler(err, req, res, next) {
  const status = err.statusCode || 500;
  const payload = {
    error: {
      message: status === 500 ? "Internal Server Error" : err.message,
      status,
      ...(err.details && { details: err.details }),
    },
  };
  if (status >= 500 || !err.isOperational) {
    console.error("[FATAL]", err);
  }
  res.status(status).json(payload);
}
```

## Uso en rutas

```js
app.get("/users/:id", async (req, res, next) => {
  try {
    const user = await repo.find(req.params.id);
    if (!user) throw new AppError("Usuario no encontrado", 404);
    res.json(user);
  } catch (e) {
    next(e);
  }
});
app.use(errorHandler);
```

---

# Mocks Avanzados en Pruebas de API

Beneficios:

- Aislamiento: pruebas enfocadas en la lógica.
- Repetibilidad: resultados deterministas.
- Velocidad: sin dependencias externas reales.

## Ejemplo con Jest (mock de servicio externo)

```js
// service.js
export async function sendEmail(payload) {
  /* llama a API externa */
}

// controller.test.js
import * as service from "../service";
jest.mock("../service", () => ({ sendEmail: jest.fn() }));

test("envía email", async () => {
  service.sendEmail.mockResolvedValue({ id: "123" });
  const res = await request(app).post("/notify").send({ to: "a@b.com" });
  expect(service.sendEmail).toHaveBeenCalled();
  expect(res.status).toBe(200);
});
```

---

# Generación de Datos con Faker.js

Permite datos realistas para escenarios variados y pruebas de carga.

```js
import { faker } from "@faker-js/faker";

function buildUser(overrides = {}) {
  return {
    id: faker.string.uuid(),
    nombre: faker.person.firstName(),
    email: faker.internet.email(),
    telefono: faker.phone.number(),
    activo: faker.datatype.boolean(),
    ...overrides,
  };
}
```

Uso combinado:

```js
const usuarios = Array.from({ length: 50 }, () => buildUser());
```

---

# Clusterización en Node.js

La ejecución en múltiplos workers mejora:

- Uso de CPU (multi-core)
- Rendimiento y throughput
- Resiliencia: reemplazo de workers caídos

## Ejemplo con cluster

```js
import cluster from "node:cluster";
import { availableParallelism } from "node:os";
import http from "node:http";

if (cluster.isPrimary) {
  const cpuCount = availableParallelism();
  console.log(`Master ${process.pid} - CPUs: ${cpuCount}`);
  for (let i = 0; i < cpuCount; i++) cluster.fork();

  cluster.on("exit", (worker) => {
    console.warn(`Worker ${worker.process.pid} murió. Reiniciando...`);
    cluster.fork();
  });
} else {
  http
    .createServer((req, res) => {
      res.end(`OK desde worker ${process.pid}`);
    })
    .listen(3000);
  console.log(`Worker ${process.pid} iniciado`);
}
```

---

# Reinicios Automáticos y PM2

PM2 aporta:

- Modo cluster
- Reinicios automáticos
- Monitoreo y logs centralizados
- Zero-downtime deploy (graceful reload)

## Comandos básicos

```bash
# Instalar
npm i -g pm2

# Ejecutar en modo cluster (todos los núcleos)
pm2 start app.js -i max --name api

# Ver estado
pm2 ls

# Logs
pm2 logs api

# Reload sin downtime
pm2 reload api

# Monitor
pm2 monit
```

## Ecosystem file (ejemplo)

```js
// ecosystem.config.js
module.exports = {
  apps: [
    {
      name: "api",
      script: "./app.js",
      instances: "max",
      exec_mode: "cluster",
      watch: false,
      env_production: {
        NODE_ENV: "production",
      },
    },
  ],
};
```

---

# Estrategia Integral

1. Middleware de errores consistente (operational vs fatal).
2. Mocks + Faker para pruebas rápidas, realistas y reproducibles.
3. Cluster + PM2 para aprovechar hardware y resiliencia.
4. Monitoreo y logging (añadir herramientas como pino, Winston, APM).
5. Automatizar CI: ejecutar pruebas, lint, build y despliegue con PM2 reload.

---

# Conclusión

Una arquitectura robusta combina:

- Gestión unificada de errores
- Pruebas aisladas con mocks y datos sintéticos
- Escalado horizontal vía cluster
- Alta disponibilidad mediante reinicios automáticos

Estas prácticas reducen downtime, mejoran rendimiento y elevan la calidad operativa del backend.
