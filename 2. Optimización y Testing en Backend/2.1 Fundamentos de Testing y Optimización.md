# Fundamentos de Testing y Optimización

## Test Driven Development (TDD) y la Importancia de los Mocks en el Desarrollo Backend

### ¿Qué es Test Driven Development (TDD)?

Test Driven Development (TDD) es una metodología en la que las pruebas se escriben antes del código funcional. El ciclo básico es:

1. Escribir una prueba (falla inicialmente).
2. Escribir el código mínimo necesario para pasarla.
3. Refactorizar manteniendo el comportamiento.

### Beneficios de TDD en Backend

- **Mayor confianza en el código:** Cada funcionalidad está cubierta por pruebas.
- **Mejor diseño:** Fomenta desacoplamiento y modularidad.
- **Documentación viva:** Las pruebas describen el comportamiento esperado.

### ¿Qué son los Mocks?

Los mocks son objetos simulados que sustituyen dependencias reales (BD, APIs externas, etc.) durante las pruebas para:

- Acelerar la ejecución.
- Aislar la lógica.
- Evitar efectos secundarios.
- Garantizar resultados consistentes.

### Importancia de los Mocks

- **Aislamiento:** Identificación rápida de errores.
- **Reproducibilidad:** Sin variaciones externas.
- **Velocidad:** Evitan I/O costoso.
- **Seguridad:** No se tocan datos reales.

### Ejemplo Conceptual (pseudocódigo)

```js
// Servicio real
const userRepo = { findById: (id) => db.query("SELECT ...") };

// En test
const userRepoMock = {
  findById: vi.fn().mockResolvedValue({ id: 1, nombre: "Ana" }),
};

const result = await servicio.obtenerUsuario(1, { userRepo: userRepoMock });
expect(result.nombre).toBe("Ana");
expect(userRepoMock.findById).toHaveBeenCalledWith(1);
```

### Conclusión TDD y Mocks

TDD mejora calidad y mantenibilidad. Los mocks permiten pruebas rápidas, aisladas y seguras al simular componentes externos.

---

## Prácticas Clave para Optimizar el Rendimiento de Servidores

Optimizar servidores asegura aplicaciones rápidas, escalables y resilientes.

### 1. Uso de Funciones Asíncronas

- **Modelo no bloqueante (Node.js).**
- **Promesas y async/await:** Código legible sin bloquear el event loop.
- **Callbacks:** Aún válidos, aunque menos usados por complejidad.

### 2. Manejo de Errores

- **Captura en async/await:** try/catch y `.catch()` en promesas.
- **Manejo global:** Middleware / listeners para errores no controlados.
- **Reinicio seguro:** Estrategias (PM2, contenedores) ante fallos críticos.

Ejemplo básico:

```js
app.use(async (req, res, next) => {
  try {
    await controlador(req, res);
  } catch (err) {
    next(err);
  }
});

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ error: "Error interno" });
});
```

### 3. Balanceo de Carga

- **Distribución de solicitudes:** Evita sobrecarga en un solo nodo.
- **Escalabilidad horizontal:** Añadir nodos según demanda.
- **Herramientas:** NGINX, HAProxy, AWS ELB, GCP Load Balancer.

Ejemplo simple NGINX (conceptual):

```
upstream app_cluster {
    server app1:3000;
    server app2:3000;
}

server {
    listen 80;
    location / {
        proxy_pass http://app_cluster;
    }
}
```

### Conclusión Optimización

Uso de asincronía, manejo robusto de errores y balanceo de carga mejora rendimiento, resiliencia y experiencia del usuario.

---

## Resumen General

- TDD: estructura, seguridad y mejor diseño.
- Mocks: pruebas rápidas y aisladas.
- Optimización: asincronía + manejo de errores + balanceo de carga = escalabilidad y estabilidad.
