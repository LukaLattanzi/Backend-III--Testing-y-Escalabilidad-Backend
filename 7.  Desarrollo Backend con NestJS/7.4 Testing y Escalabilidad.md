# Testing y Escalabilidad

## Revisión de las Diferentes Estrategias de Testing en NestJS

El testing asegura que el código funcione como se espera y que los cambios no introduzcan errores. En NestJS las pruebas se agrupan en:

- Pruebas unitarias
- Pruebas de integración
- Pruebas funcionales (E2E)

---

### 1. Pruebas Unitarias

**Descripción:** Verifican unidades individuales (servicios, controladores, clases) en aislamiento.  
**Objetivo:** Garantizar que cada unidad funcione correctamente simulando (mock) las dependencias.  
**Herramientas:** Jest (mocks, spies, aserciones).  
**Ejemplo:** Probar un servicio de cálculos (suma, resta, multiplicación, división) con varias entradas y salidas esperadas.

---

### 2. Pruebas de Integración

**Descripción:** Validan que módulos o componentes funcionen correctamente combinados (servicio + base de datos, controlador + servicio).  
**Objetivo:** Detectar fallos en interacción entre componentes que no emergen en pruebas unitarias.  
**Herramientas:** Jest + BD en memoria (SQLite) o simulaciones de servicios externos.  
**Ejemplo:** Probar operaciones CRUD de usuarios verificando interacción entre servicio y repositorio.

---

### 3. Pruebas Funcionales (E2E)

**Descripción:** Verifican el sistema completo desde la perspectiva del cliente (HTTP request → response).  
**Objetivo:** Asegurar que rutas, controladores y servicios trabajan juntos en escenarios reales.  
**Herramientas:** Supertest (peticiones HTTP contra la app NestJS).  
**Ejemplo:** Endpoint de autenticación: credenciales válidas → 200 + JWT; inválidas → 401.

---

## Introducción a Supertest para Pruebas Funcionales

Supertest permite simular solicitudes HTTP y validar respuestas en pruebas E2E.

### Pasos para usar Supertest en NestJS

1. Instalación:

```bash
npm install --save-dev supertest jest
```

2. Configuración:

- Crear archivo de prueba (por ejemplo: auth.e2e-spec.ts).
- Usar TestingModule y crear la app con `NestFactory` o `moduleRef.createNestApplication()`.

3. Escribir pruebas:

```ts
import { Test } from "@nestjs/testing";
import { INestApplication } from "@nestjs/common";
import * as request from "supertest";
import { AppModule } from "../src/app.module";

describe("Auth (E2E)", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  it("POST /auth/login (200)", async () => {
    return request(app.getHttpServer())
      .post("/auth/login")
      .send({ email: "user@test.com", password: "Pass123!" })
      .expect(200)
      .expect((res) => {
        expect(res.body).toHaveProperty("access_token");
      });
  });

  it("POST /auth/login (401)", async () => {
    return request(app.getHttpServer())
      .post("/auth/login")
      .send({ email: "user@test.com", password: "Wrong" })
      .expect(401);
  });

  afterAll(async () => {
    await app.close();
  });
});
```

4. Ejecución:

```bash
npm run test:e2e
```

---

## Conclusión

- Pruebas unitarias: validan piezas aisladas.
- Pruebas de integración: verifican interacción entre componentes.
- Pruebas funcionales: validan el sistema completo.

Con Jest y Supertest se mejora la confiabilidad, se reducen errores en producción y se mantiene la calidad del software.
