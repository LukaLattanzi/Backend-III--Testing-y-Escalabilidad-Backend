# Autenticación y Seguridad en NestJS

## Introducción

La autenticación es un componente crucial en la mayoría de las aplicaciones web: permite identificar y verificar a los usuarios antes de concederles acceso a recursos protegidos. Una forma común y segura de implementarla es mediante JSON Web Tokens (JWT). NestJS facilita su integración de manera eficiente y segura.

---

## ¿Qué es JWT (JSON Web Token)?

JWT es un estándar que define una forma compacta y autónoma de transmitir información como un objeto JSON firmado.

Un token se compone de tres partes (separadas por puntos):

1. **Header**: Tipo de token y algoritmo (ej. HS256).
2. **Payload**: Claims (información del usuario y metadatos).
3. **Signature**: Firma generada a partir del header + payload + clave secreta.

Ejemplo estructural:

```
xxxxx.yyyyy.zzzzz
```

---

## Flujo de Autenticación con JWT

1. **Inicio de sesión**: El cliente envía credenciales.
2. **Verificación**: El servidor valida las credenciales.
3. **Generación del token**: Se firma un JWT (ej. con el userId).
4. **Entrega**: El token se devuelve al cliente (localStorage o cookie segura).
5. **Acceso a rutas protegidas**: El cliente envía el token en el header Authorization: Bearer <token>.
6. **Validación por solicitud**: El servidor valida la firma y los claims.
7. **Respuesta**: Si es válido, accede; si no, se rechaza (401 / 403).

---

## Instalación de Paquetes (JWT + Passport)

```bash
npm install @nestjs/jwt @nestjs/passport passport passport-jwt
```

- `@nestjs/jwt`: Utilidades para firmar/verificar tokens.
- `@nestjs/passport`: Integración de estrategias.
- `passport-jwt`: Estrategia para extraer y validar JWT.

---

## Configuración Básica del Módulo de Autenticación

Ejemplo mínimo (simplificado):

```ts
// auth.module.ts
import { Module } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";
import { PassportModule } from "@nestjs/passport";
import { JwtStrategy } from "./jwt.strategy";
import { AuthService } from "./auth.service";
import { AuthController } from "./auth.controller";

@Module({
  imports: [
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET || "dev_secret",
      signOptions: { expiresIn: "1h" },
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}
```

```ts
// jwt.strategy.ts
import { Injectable } from "@nestjs/common";
import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      secretOrKey: process.env.JWT_SECRET || "dev_secret",
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
    });
  }

  async validate(payload: any) {
    // payload contiene lo que firmaste (ej. { sub: userId, username })
    return { userId: payload.sub, username: payload.username };
  }
}
```

```ts
// auth.service.ts
import { Injectable } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";

@Injectable()
export class AuthService {
  constructor(private jwt: JwtService) {}

  async login(user: { id: number; username: string }) {
    const payload = { sub: user.id, username: user.username };
    return { access_token: this.jwt.sign(payload) };
  }
}
```

```ts
// auth.controller.ts
import { Controller, Post, Body } from "@nestjs/common";
import { AuthService } from "./auth.service";

@Controller("auth")
export class AuthController {
  constructor(private auth: AuthService) {}

  @Post("login")
  async login(@Body() body: { username: string; password: string }) {
    // Validar credenciales (omitido)
    const user = { id: 1, username: body.username };
    return this.auth.login(user);
  }
}
```

Uso del guard en rutas protegidas:

```ts
import { Controller, Get, UseGuards } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";

@Controller("profile")
export class ProfileController {
  @UseGuards(AuthGuard("jwt"))
  @Get()
  getProfile() {
    return { ok: true };
  }
}
```

---

## Protección de Rutas con Guards

- **A nivel de controlador**: Se aplica a todas las rutas del controlador.
- **A nivel de método**: Solo a endpoints específicos.
- **Custom Guards**: Puedes extender AuthGuard o implementar CanActivate.

---

## Resumen de Buenas Prácticas JWT

- No almacenar JWT en localStorage si manejas datos sensibles (preferir cookies httpOnly + CSRF).
- Rotar claves y usar expiración corta (ej. 15m + refresh token).
- Incluir solo datos mínimos en el payload.
- Verificar audiencia (aud), emisor (iss) y tiempos (iat, exp) si aplica.

---

# Uso de Middlewares en NestJS

## ¿Qué es un Middleware?

Función que se ejecuta antes de llegar al controlador. Puede:

- Leer/modificar request/response
- Terminar el ciclo
- Delegar al siguiente middleware

## Creación de un Middleware

```ts
// logger.middleware.ts
import { Injectable, NestMiddleware } from "@nestjs/common";
import { Request, Response, NextFunction } from "express";

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log(
      `[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`
    );
    next();
  }
}
```

## Aplicación en un Módulo

```ts
// app.module.ts
import { Module, MiddlewareConsumer } from "@nestjs/common";
import { LoggerMiddleware } from "./logger.middleware";

@Module({
  imports: [],
})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes("*"); // Rutas específicas o { path: 'auth', method: RequestMethod.POST }
  }
}
```

## Niveles de Aplicación

- Aplicación completa: forRoutes('\*')
- Módulo específico: definir en su módulo
- Ruta puntual: path + method
- Exclusiones: .exclude({ path: 'health', method: RequestMethod.GET })

## Casos de Uso Comunes

- Logging
- Rate limiting (complementar con librerías)
- Sanitización / normalización de headers
- Inyección de correlación (traceId)
- Pre-validación básica antes de pipes

---

## Diferencia Middleware vs Guard vs Interceptor

- Middleware: Pre-controller (stack Express/Fastify)
- Guard: Control de autorización / activación del handler
- Interceptor: Transforma request/response alrededor del handler
- Pipe: Transformación / validación de datos
- Filter: Manejo de excepciones

---

## Conclusión

JWT en NestJS permite una autenticación desacoplada y eficiente. Combinado con guards, asegura acceso controlado a recursos. Los middlewares añaden una capa flexible para tareas transversales (logging, métricas, preprocesado). Una arquitectura limpia separa preocupaciones y mejora mantenibilidad y seguridad.

- Implementa expiración y rotación de tokens.
- Limita claims en el payload.
- Usa guards para autorización fina.
- Centraliza lógica transversal en middlewares e interceptores.

Con estas bases, tu backend NestJS será más seguro, escalable y mantenible.
